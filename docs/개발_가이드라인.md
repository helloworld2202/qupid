# 달램 워크스페이스 개발 가이드라인

> Stack: **TypeScript**, **React(Web)** + **React Native(WebView)**, **Node.js(Express)**, **Supabase(Postgres/Auth/Storage/Realtime)** 목표: **일관성**, **가독성**, **테스트 용이성**, **확장성**

---

## 0) 핵심 원칙 (Compact)

- **한 레이어 = 한 책임**: Controller는 입·출력, Service는 도메인 규칙, Repository는 데이터 접근.
- **의존성은 아래→위 주입**: 상위가 하위를 모른다(Interface로 의존).
- **타입 우선**: 런타임 검증(Zod) + 컴파일 타입(TS) 모두 사용.
- **불변/순수 함수 선호**, 필요할 때만 클래스(도메인 엔티티) 사용.
- **실패를 표준화**: 에러 포맷, 로깅, 트랜잭션/재시도 규칙 고정.
- **기본은 REST, 강한 일관성**: /v1, snake\_case DB ↔ camelCase API 매핑.

---

## 1) 모노레포 구조(권장)

```
/ (repo)
  /apps
    /web        # React 웹앱
    /mobile     # React Native 쉘(WebView)
    /api        # Express API 서버
  /packages
    /ui         # 공용 UI 컴포넌트(웹)
    /core       # 도메인 모델/유틸(순수 TS)
    /config     # eslint, tsconfig, prettier 등 공통 설정
```

- pnpm 워크스페이스 사용 권장. 공통 tsconfig/eslint/prettier는 `/packages/config`에서 공유.

---

## 2) 코드 스타일 & 툴링

- **TypeScript**: `"strict": true`, `noImplicitAny: true`, `exactOptionalPropertyTypes: true` 권장.
- **ESLint/Prettier**: @typescript-eslint + import 규칙(알파벳/그룹 정렬).
- **경로 별칭**: `@core/*`, `@ui/*`, `@api/*`, `@app/*` 등.
- **커밋 규칙**: Conventional Commits(`feat:`, `fix:`, `chore:`…).
- **PR 규칙**: lint+typecheck+test 통과 필수. 작은 PR(≤300줄) 지향.
- **Git Hooks**: husky + lint-staged(수정 파일만 lint/format).

---

## 3) 객체지향 설계 가이드(라이트 웨이트)

### 3.1 레이어드 아키텍처

- **Domain(Entity/Aggregate)**: 비즈니스 상태/불변식 캡슐화. 생성자/팩토리에서 유효성 보장.
- **Repository(Interface)**: `find/save` 등 영속화 계약. 구현은 Supabase/SQL 디테일 숨김.
- **Service**: 유스케이스 오케스트레이션(트랜잭션, 도메인 규칙 조합).
- **Controller**: DTO ↔ Domain 매핑, 입력 검증, 에러 매핑.

### 3.2 의존성 주입

- **Constructor Injection** 기본. `composition root`(앱 시작부)에서 wiring.
- 외부 DI 라이브러리 없이도 **팩토리 함수**로 충분. 필요 시 `tsyringe` 채택.

### 3.3 에러 전략

- 공통 `AppError(code: string, message: string, status: number, cause?)`.
- Controller에서 **에러 미들웨어**로 표준 JSON 변환.
- 재시도/보상 트랜잭션은 Service에서만.

### 3.4 검증

- **Zod**로 DTO/환경변수/설정 런타임 검증. 스키마는 재사용.

---

## 4) 백엔드(Express) 가이드

### 4.1 폴더 구조

```
/apps/api/src
  /modules/<feature>
    /domain      # 엔티티, 값 객체, 도메인 서비스
    /app         # use-cases(Application service)
    /infra       # repository 구현(Supabase), 외부 서비스
    controller.ts
    routes.ts
  /shared       # 오류, 로깅, config, zod, middleware
  server.ts
```

### 4.2 Supabase 연동

- **supabase-js(Server)** 사용: Auth/Storage/Realtime. 서비스 로le 키는 **서버 전용**.
- **DB 접근 우선순위**: PostgREST(테이블/뷰) → 복잡 쿼리는 **SQL 함수(rpc)**.
- **RLS 활성화**: 정책으로 접근 제어, 서버는 최소 권한 키를 사용.
- 마이그레이션: **Supabase CLI** + SQL. PR에 마이그레이션 파일 포함.

### 4.3 Express 표준

- 라우팅: `routes.ts`에서 선언 → controller 바인딩.
- 미들웨어: `helmet`, `cors(허용 도메인 화이트리스트)`, `rate-limit`, `pino-http`.
- 에러 핸들링: 마지막에 `errorHandler` 하나.
- 응답 형태(예):

```json
{ "ok": true, "data": { ... } }
{ "ok": false, "error": { "code": "...", "message": "..." } }
```

### 4.4 예시(간단)

```ts
// domain/User.ts
export class User {
  constructor(readonly id: string, private _name: string) {
    if (!_name.trim()) throw new Error('name required');
  }
  get name() { return this._name; }
  rename(n: string) { if (!n.trim()) throw new Error('bad'); this._name = n; }
}

// app/UpdateUserName.ts
export class UpdateUserName {
  constructor(private users: UsersRepo) {}
  async exec(input: { id: string; name: string }) {
    const u = await this.users.findById(input.id);
    if (!u) throw new AppError('NOT_FOUND','user',404);
    u.rename(input.name);
    await this.users.save(u);
    return u;
  }
}

// infra/UsersRepoSupabase.ts
export class UsersRepoSupabase implements UsersRepo {
  constructor(private sb: SupabaseClient) {}
  async findById(id: string) { /* select from table */ }
  async save(u: User) { /* upsert */ }
}

// controller.ts
const schema = z.object({ id: z.string().uuid(), name: z.string().min(1) });
export const updateUser = (uc: UpdateUserName): RequestHandler => async (req,res,next)=>{
  try { const input = schema.parse(req.body); const u = await uc.exec(input);
    res.json({ ok:true, data: { id: u.id, name: u.name } });
  } catch(e){ next(e); }
};
```

### 4.5 테스트

- **Vitest/Jest** + **supertest**(HTTP), **testcontainers** or Supabase test project.
- 유스케이스 단위 테스트(서비스), 인수 테스트(엔드투엔드) 최소화면.

---

## 5) 프론트엔드(Web: React)

### 5.1 구조(Feature-first)

```
/apps/web/src
  /app        # 라우팅/전역 레이아웃
  /shared     # ui, lib, hooks, api 클라이언트, config
  /entities   # 도메인 상태/타입(뷰 독립)
  /features   # 유스케이스 단위 컴포넌트+상태
  /pages      # 라우트 단위(Next.js 사용 시)
```

- 상태관리: **TanStack Query**(서버 상태) + **Zustand**(로컬/글로벌 경량) 권장.
- 스타일: **Tailwind CSS** + 공용 UI(`@packages/ui`).
- 폼: **react-hook-form** + **zodResolver**.
- API: `apiClient` 래퍼(에러/재시도/토큰 주입 일원화).

### 5.2 컴포넌트 규칙

- Presentational(Container 분리): 도메인 로직은 hooks/service로 추출.
- 파일명: PascalCase 컴포넌트, camelCase 훅.
- props는 **필수 최소화**, 옵셔널은 명시적 기본값.
- 스토리북 작성(핵심 UI는 스냅샷 테스트).

### 5.3 WebView 브릿지

- RN ↔ Web 통신: `window.ReactNativeWebView.postMessage` / `onMessage`.
- **버전드 브릿지**: `{version: 1, type: 'AUTH_TOKEN', payload: ...}` 형태.
- 민감 정보는 RN에서 보관(secure storage). Web은 **세션 토큰만 주입**.
- 초기 로드 시 RN이 Web에 `INIT` 이벤트로 환경정보 전달.

---

## 6) 모바일(React Native 쉘)

- 단일 스크린에 WebView 탑재, 네이티브 기능은 **브릿지 서비스**로 추상화.
- 네이티브 권한/딥링크/푸시 처리는 RN에서 담당 → Web에 이벤트 전달.
- WebView 설정: `javaScriptEnabled`, `domStorageEnabled`, `injectedJavaScript`(초기 토큰 주입 금지, 브릿지 이벤트 선호).

---

## 7) API 규약

- **Prefix**: `/api/v1` (버전 필수).
- **자원 지향**: 복수형, `GET /users/:id`, `POST /users`.
- **페이징**: `?limit=20&cursor=...`(커서 기반 권장). 응답에 `nextCursor` 포함.
- **에러 코드**: `USER_NOT_FOUND`, `INVALID_INPUT`, `PERMISSION_DENIED` 등 도메인별 사전 정의.
- **Idempotency**: 재시도 가능한 POST는 `Idempotency-Key` 지원.

---

## 8) 보안/운영

- **Auth**: Supabase Auth(JWT). 서버는 헤더의 Bearer 토큰 검증.
- **RLS**: 사용자별 소유 리소스는 `uid()` 기반 정책 필수.
- **Secrets**: 서비스 role 키는 서버 전용, 클라이언트 빌드에 포함 금지.
- **CORS**: 허용 도메인 명시, 자격증명 필요 시 쿠키/헤더 정책 결정.
- **로깅**: pino(서버), Sentry(웹/서버) 적용. 로그에 PII 금지.
- **관측성**: 기본 메트릭(요청 시간/에러율), 헬스체크 `/healthz`.

---

## 9) 데이터 & 마이그레이션

- 이름 규칙: 테이블/컬럼 `snake_case`, 기본키 `id`(UUID), 타임스탬프 `created_at/updated_at`(timestamptz).
- FK는 `on delete cascade` 명시. 인덱스/제약조건은 마이그레이션에 포함.
- Seed/샘플 데이터는 분리. 롤백 스크립트 포함.

---

## 10) 테스트 전략(요약)

- **단위**: 도메인/서비스(비즈니스 규칙) 우선.
- **통합**: Repository↔Supabase 경계.
- **E2E(선택)**: 핵심 플로우만.
- 커버리지 목표: statements 80%+, critical path 100%.

---

## 11) 품질 체크리스트 (PR용)

-

---

## 12) 환경 변수(예)

```
# /apps/api/.env
NODE_ENV=development
PORT=4000
SUPABASE_URL=...
SUPABASE_SERVICE_ROLE_KEY=...
JWT_AUDIENCE=...
```

- Zod로 환경 스키마를 검증(`process.env` 파싱 시 실패하면 부팅 중단).

---

## 13) 문서화

- ADR(Architectural Decision Record) 짧게 남김: 문제/대안/결정/근거/영향.
- API 명세: OpenAPI 또는 typed client 코드 생성.

---

### 부록: 최소 보일러플레이트(Express)

```ts
// server.ts
const app = express();
app.use(helmet());
app.use(express.json());
app.use(requestId());
app.use(pinoHttp());
app.use('/api/v1/users', usersRoutes());
app.use(errorHandler());
```

```ts
// shared/error.ts
export class AppError extends Error {
  constructor(
    public code: string,
    message: string,
    public status = 400,
    public cause?: unknown
  ) { super(message); }
}
export const errorHandler: ErrorRequestHandler = (err, _req, res, _next) => {
  const e = err instanceof AppError ? err : new AppError('INTERNAL', 'unexpected', 500, err);
  res.status(e.status).json({ ok: false, error: { code: e.code, message: e.message } });
};
```

```ts
// shared/env.ts
const Env = z.object({ SUPABASE_URL: z.string().url(), SUPABASE_SERVICE_ROLE_KEY: z.string().min(1) });
export const env = Env.parse(process.env);
```

> 이 문서는 베이스라인입니다. 프로젝트가 커지면 각 모듈 README/ADR로 세부 규칙을 확장하세요.

